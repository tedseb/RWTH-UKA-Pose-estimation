# GENERAL CONFIGURATION (not algorithmic)

MONGO_DB_URI: "mongodb://mongoadmin:secret@localhost:27888/?authSource=admin"

DEFAULT_JOINT_ADAPTER: 'src.joint_adapters.metrabs'

ROS_TOPIC_USER_EXERCISE_STATES: 'user_state'
ROS_TOPIC_USER_CORRECTIONS: 'user_correction'

ROS_JOINTS_TOPIC: 'fused_skelleton' #Â Shawan's topic choice
ROS_STATION_USAGE_UPDATE_TOPIC: 'station_usage'
ROS_SKELLETON_DEFINITION: 'skelleton_name'

ROS_MOTION_ANALYSIS_INPUT_VISUALIZER_TOPIC: "motion_analysis_input_markers"
ROS_MOTION_ANALYSIS_REFERENCE_POSE_VISUALIZER_TOPIC: "motion_analysis_reference_prediction_markers"

SHOW_ROOM_VIDEO_REFERENCE: "showroom_video_reference" # Number of the frame in the original recording
SHOW_ROOM_REFERENCE_PROGRESS_TOPIC: "showroom_reference_progress" # Number between 0 and 100 that represents the progress

REDIS_MAXIMUM_QUEUE_SIZE: 1000
REDIS_QUEUE_SIZE_PANIC_BOUNDARY: 200
REDIS_MAXIMUM_PAST_QUEUE_SIZE: 100
REDIS_KEY_SEPARATOR: ":"

REDIS_USER_STATE_SENDING_QUEUE_NAME: "user_state_sending_queue"
REDIS_USER_INFO_SENDING_QUEUE_NAME: "user_correction_sending_queue"
REDIS_LOAD_BALANCER_SORTED_SET_KEY: "spot_queue_load_balancer_list"
REDIS_LOAD_BALANCER_ACTIVE_COMPARATORS_SORTED_SET_KEY: "spot_queue_load_balancer_active_comparators"  # Currently not in use

QUEUEING_USER_STATE_QUEUE_SIZE_MAX: 100
QUEUEING_USER_INFO_QUEUE_SIZE_MAX: 100

# Incase other people want to use the same redis database, better use a prefix for keys so our data does not collide
REDIS_GENERAL_PREFIX: "motion_analysis"
REDIS_SPOT_QUEUE_POSTFIX: "pose_queue"
REDIS_SPOT_PAST_QUEUE_POSTFIX: "pose_queue_past"
REDIS_SPOT_INFO_POSTFIX: "spot_info"
REDIS_SPOT_FEATURES: "features"
REDIS_SPOT_EXERCISE_POSTFIX: "exercise"

SEND_CORRETIONS: False
JOINT_DIFFERENCE_FADING_FACTOR: 0.8

# FPS for the GUI
GUI_FPS: 25

# ALGORITHMIC COMFIGURATION

# 0 means that user has to reach angle at least as high/low as performed by expert
# 1 means that the boundaries are swapped (and makes no sense)
REDUCED_RANGE_OF_MOTION_TOLERANCE_LOWER: 0.41
REDUCED_RANGE_OF_MOTION_TOLERANCE_HIGHER: 0.41

# The final feature trajectory resolution is: FEATURE_TRAJECTORY_RESOLUTION_FACTOR  * range of motion of a single feature
FEATURE_TRAJECTORY_RESOLUTION_FACTOR: 0.03

DIGITIZED_FEATURE_TRAJECTORY_MAX_MEMORY_SIZE: 60
FEATURE_TRAJECTORY_MAX_MEMORY_SIZE: 90
STATES_TRAJECTORY_MAX_MEMORY_SIZE: 30

# We have a resolution of ten steps between minimum and maximum of a trajectory. We remove 4 such steps of jittering, if found.
REMOVE_JITTER_RANGE: 10

ENABLE_JUMPY_PROGRESS_CHECK: False
JUMPY_PROGRESS_ALPHA: 3
JUMPY_PROGRESS_BETA: 4

TRUST_REGION_FILTER_FACTOR: 10

ENABLE_FEATURE_ALIGNMENT_CHECK: False
MINIMAL_ALLOWED_MEAN_FEATURE_ALIGNMENT: 0.80

# We use this fading factor for a exponentially dying error 
JOINT_DIFFERENCE_FADING_FACTOR: 0.8

ENABLE_NUM_FEATURES_TO_PROGRESS_CHECK: False
NUM_FEATURE_TO_PROGRESS_ALPHA: 1.5
NUM_FEATURE_TO_PROGRESS_BETA: 0.9

ENABLE_NUM_FEATURES_PROGRESSED_TOO_FAR_CHECK: False
NUM_FEATURES_PROGRESSED_TOO_FAR_MU: 1

PROGRESS_VELOCITY_EPSILON: 0.6


# These has to be heuristically determined, as is depends on the size of the normal skelleton! Careful!
SCORE_ALPHA: 0.1 # We scale directly with this!
SCORE_BETA: 0.13 # We add this to our number before clipping it
SCORE_GAMMA: 4 # We take our number to the power of gamma to emphasize bad scores as being much more near to zero
SCORE_SIGMA: 2.8 # Have a look at the code to see what happens inside the tanh here
SCORE_YOTTA: 0.23 # Add this in the end to get scores closer to 1 if they are quite good